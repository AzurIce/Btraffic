依赖安装：

```
pip install pandas matplotlib openpyxl numpy scipy plotly
```



## EBI/SBI

进行紧急制动的过程中由于「牵引切断时延」和「制动建立时延」会导致存在三个阶段：

1. 牵引延时：加速度为 **牵引加速度**，持续 $t_0$
2. 制动延时：加速度为 $0$，持续 $t_1$
3. 制动：加速度为 **紧急/常用制动率**

首先有一个直观的理解：前面的位置的速度，由后面的位置的速度要求决定。

- 如果后面没有限速，那前面就可以“放飞自我”
- 如果后面存在限速，那前面就要“有所收敛”
- <u>如果一路踩着刹车到后面，刚好卡在限速上，那前面无论如何都不能再快</u>

所以使用逆向递推的方式来求解曲线。

在实际实现上，数据是离散的采样点，而非连续的曲线，计算机也没有两条曲线取最小的直觉，只能比较同一 $x$ 处的 $y$。。

### 先推出一条只考虑 3 的曲线 —— 制动的“底线”

假设对于 $x > x_0$ 的速度均已得到，那么 $x_0$ 处的速度 $v(x_0)$ 受到其后 $\delta_t \in [0, +\infty]$ 时间内的速度的限制：
$$
v(x_0) \leq \sqrt{-2a\delta_x + v(x_0 + \delta_x)^2}, \delta_t > 0
$$
或者说如果我们已知 $x_1$ 处的速度 $v(x_1)$，那么它会限制其前 $\delta_t \in [0, +\infty]$ 时间内的速度：
$$
v(x_1 - \delta_x) \leq \sqrt{-2a\delta_x + v(x_1 - \delta_x)^2}, \delta_t > 0
$$
那么将静态限速曲线作为输入，从最右端开始，向左一次次“捋”过去，最终就可以得到我们想要的曲线。

这里可以将每一次“捋”到头的操作优化合并为只“捋”一个单位长度，因为从“捋”过的地方再捋的效果可以覆盖。

### 然后由这条曲线作为输入，考虑 2 —— 开始制动延时的底线

假设对于 $x > x_0$ 的速度均已得到，那么 $x_0$ 处的速度 $v(x_0)$ 受到其后 $\delta_t \in [0, t_1]$ 时间内的速度的限制：
$$
v(x_0) \leq  v(x_0 + \delta_x), \ 0 \leq \delta_t < t_1
$$
或者说如果我们已知 $x_1$ 处的速度 $v(x_1)$，那么它会限制其前 $\delta_t \in [0, t_1]$ 时间内的速度：
$$
v(x_1 - \delta_x) \leq v(x_1), \ 0 \leq \delta_t < t_1
$$
现在我们希望能够用 $\delta_x$ 来表示 $\delta_t$，可以转化为：
$$
v(x_1 - \delta_x) \leq v(x_1), \ 0 \leq \delta_x < v(x_1)t_1
$$

用这个式子逆着再递推一遍就好了。

### 然后由这条曲线作为输入，考虑 1 —— 开始牵引延时的底线

假设对于 $x > x_0$ 的速度均已得到，那么 $x_0$ 处的速度 $v(x_0)$ 受到其后 $\delta_t \in [0, t_0]$ 时间内的速度的限制：
$$
v(x_0) \leq v(x_0 + \delta_x) - at_0, \ 0 \leq \delta_t \leq t_0
$$
或者说如果我们已知 $x_1$ 处的速度 $v(x_1)$，那么它会限制其前 $\delta_t \in [0, t_0]$ 内的速度：
$$
v(x_1 - \delta_x) \leq v(x_1) - a(\delta_t - t_0), \ 0 \leq \delta_t \leq t_0
$$
现在我们希望能够用 $\delta_x$ 来表示 $\delta_t$，可以转化为：
$$
v(x_1 - \delta_x) \leq 
	\sqrt{-2a\delta_x + v(x_1)^2}, \ 0 \leq \delta_x \leq v(x_1)t_0 - \frac{1}{2}at_0^2
$$

用这个式子逆着再递推一遍就好了。

---






![image-20240604164314449](./assets/image-20240604164314449.png)
